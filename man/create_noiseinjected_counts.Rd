\name{create_noiseinjected_counts}
\alias{create_noiseinjected_counts}
\alias{HPC_genewise_permute_count}
\alias{HPC_permute_count}
\alias{HPC_randomizer}
\alias{prepare_probabilities}
\alias{randomizer}
\alias{permute_count}
\alias{genewise_permute_count}
\alias{execute_noiseinjected_counts}
\alias{cl}
\alias{gene_name}
\alias{example_code}

\title{
Computes BEARscc simulated technical replicates.
}
\description{
Computes BEARscc simulated technical replicates from the 
    previously estimated noise parameters computed with the 
    function \code{estimate_noise_parameters()}.
}
\usage{
create_noiseinjected_counts(noise_parameters, total_sampling=2500, n = 3)
}

\arguments{
\item{noise_parameters}{
A list directly output \code{estimate_noiseparameters()}.
}
\item{total_sampling}{
A parameter describing the total number of values to sample to describe the 
    estimated noise model before sampling a value based on the observed count.
}
\item{n}{
The number of simulated technical replicates to generate.
}
}
\details{
In the second step of BEARscc, the algorithm applies the model from first 
    step to produce simulated technical replicates. For every observed 
    gene count below which drop-outs occurred amongst the spike-ins, 
    BEARscc assesses whether to convert the count to zero (using the 
    drop-out injection distribution). For observations where the count is 
    zero, the drop-out recovery distribution is used to estimate a new value, 
    based on the overall drop-out frequency for that gene. After this 
    drop-out processing, all non-zero counts are substituted with a value 
    generated by the model of expression variance created in the first step. 
    parameterized to the observed counts for each gene. This second step is 
    repeated any number of times (as prescribed by parameter \code{n}) to 
    generate a collection of simulated technical replicates for 
    downstream analysis.
}
\value{
The resulting object is a list of counts data, where each element of the list 
    is a data.frame of the counts representing a BEARscc simulated technical 
    replicate, e.g for \code{n=10} we would have the list:
\tabular{ccl}{
    [,1] \tab \tab Counts data.frame of simulated replicate 1. \cr
    [,2] \tab \tab Counts data.frame of simulated replicate 2.\cr
    [,3] \tab \tab Counts data.frame of simulated replicate 3.\cr
    [,4] \tab \tab Counts data.frame of simulated replicate 4.\cr
    [,5] \tab \tab Counts data.frame of simulated replicate 5.\cr
    [,6] \tab \tab Counts data.frame of simulated replicate 6.\cr
    [,7] \tab \tab Counts data.frame of simulated replicate 7.\cr
    [,8] \tab \tab Counts data.frame of simulated replicate 8.\cr
    [,9] \tab \tab Counts data.frame of simulated replicate 9.\cr
    [,10] \tab \tab Counts data.frame of simulated replicate 10.\cr
    [,11] \tab \tab Counts data.frame of observed data.\cr
    }
}

\author{
\packageAuthor{BEARscc}

Maintainer: \packageMaintainer{BEARscc}
}

\section{A brief description of subfunctions}{
    \code{create_noiseinjected_counts} relies on the following subfunctions 
    to generate simulated technical replicates. These functions share many 
    common options with the user interactive function. For those options 
    that are internal to the programming; these are annotated to give an 
    idea of flow. For further detail please examine source code in the R 
    directory of this package:\cr
\itemize{
    \item \code{spikes_prepared <- execute_noiseinjected_counts(n=1, 
        noise_parameters=estimated_noise, total_sampling)}
    \item \code{probs4detection.genes<-t(data.frame(
        noise_parameters$bayes_parameters, row.names = "k")[,
        4:eval(dim(noise_parameters$bayes_parameters)[2]-1)])}
    \item \code{probs4detection.k<-data.frame(
        noise_parameters$bayes_parameters[,2:4, with=FALSE],row.names = "k")}
    \item \code{noisy_counts<-data.table(noise_parameters$original.counts, 
        keep.rownames = TRUE)[,apply(.SD,1 ,`genewise_permute_count`, 
        probs4detection.k=probs4detection.k, 
        probs4detection.genes=probs4detection.genes, 
        parameters=noise_parameters$ERCC_parameters, 
        total_sampling=total_sampling)]}
    \item \code{probabilityA<-probs4detection.genes[gsub("-",".",x[1]),]}
    \item \code{apply(data.frame(as.numeric(x[-1])),1, `permute_count`, 
        probs4detection.k, probabilityA=probabilityA, 
        parameters, total_sampling)}
    \item Under various conditions some form of \code{nx<-randomizer(x, 
        parameters, total_sampling)} is invoked.
    }
}

\note{
Frequently, the user will want to compute simulated technical replicates 
    in a high performance computational environment. When running 
    \code{estimate_noiseparamters} using the option 
    \code{write.noise.model=TRUE}, the user recives the files with 
    root \code{file=Rfile}, "Rfile_bayesianestimates.xls" and 
    "Rfile_parameters4randomize.xls". These files may be input into 
    the example code, \code{HPC_generate_noise_matrices.R}, on a high 
    performance computational environment for faster processing.
}

\seealso{
The example code for running the simulation of technical replicates 
    on a high performance computing cluster can be found 
    in \code{R/HPC_generate_noise_matrices.R}.

The code for generating simulated technical replicates on a high powered 
    compute node requires the functions (which operate analogously to 
    their counterparts desigined to be run on a local machine):
\itemize{
    \item{\code{prepare_probabilities()}}
    \item{\code{HPC_genewise_permute_count()}}
    \item{\code{HPC_randomizer()}}
    \item{\code{HPC_permute_count()}}
}

Of note the variable \code{cl} in the function \code{prepare_probabilities()} 
    is the number of clusters created by the CRAN package \code{parallel}.
}


\examples{
data(analysis_examples)

sim_replicates<-create_noiseinjected_counts(estimated_noise, n=3)
sim_replicates

}
\keyword{ models }
\keyword{ robust }
